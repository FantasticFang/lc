#### KMP算法

- KMP算法的核心是，求解某一个字符串相等真前缀、真后缀的最大长度（真前缀/真后缀 != 字符串本身）。对于字符串s="abcasabc"（下文主串将定义为s）
  - 前缀函数：f(0) = 0， 因为"a"没有自己的真前缀和真后缀
  - f(1) = 0
  - f(2) = 0
  - f(3) = 1，因为s[0] = s[3]
  - f(4) = 0
  - f(5) = 1，因为s[0] = s[5]
  - f(6) = 2，因为s[0, 1] = s[5, 6]
  - f(7) = 3，因为s[0, 2] = s[5, 7]
- 前缀函数的性质，f(n) = j，那么s[0, j-1] = s[n-j+1,n] --「公式1」
- 前缀函数在字符串匹配中的作用？
  - 假设主串s="abcasabc"，模式串t="cas"
  - 如果我们将模式串和主串，用一个不会出现的字符"#"号连接，得到字符串p="cas#abcasabc"
  - 如果对p求解前缀函数，那么f(8) = 3，此时3 === t.length，模式串在主串的出现的start = 8 -「拼接的前缀长度」-「f(8)」 + 1 = 2，那么end =  8 -「拼接的前缀长度」= 4，所以模式串t在主串s中的位置是s[2， 4]
- 前缀函数的求解过程：
  - 假设f(n) = j，求解f(n + 1)，那么如果s[j] = s[n + 1]，由「公式1」可得，s[0, j] = s[n-j+1, n + 1]，可以推断f(n + 1) = j + 1
  - 假设f(n) = j，求解f(n + 1)，那么如果s[j] != s[n + 1]，情况比较麻烦一些
    - 朴素求解：依次核对s[0] = s[n + 1]？、s[1] = s[n]?、s[2] = s[n-1]?...，这么求解出来的话，时间复杂度将会变成o(n2)
    - 因此需要利用前缀函数的特性来求解，在假定条件下，有s[0, j-1] = s[n-j+1,n]，那么「公式1」两边字符串前缀均加x，s[x, j-1] = s[n-j+1+x, n]是成立的（其中x < j-1）
