#### KMP算法

- KMP算法的核心是，求解某一个字符串相等真前缀、真后缀的最大长度（真前缀/真后缀 != 字符串本身）。对于字符串s="abcasabc"（下文主串将定义为s）
  - 前缀函数：f(0) = 0， 因为"a"没有自己的真前缀和真后缀
  - f(1) = 0
  - f(2) = 0
  - f(3) = 1，因为s[0] = s[3]
  - f(4) = 0
  - f(5) = 1，因为s[0] = s[5]
  - f(6) = 2，因为s[0, 1] = s[5, 6]
  - f(7) = 3，因为s[0, 2] = s[5, 7]
- 前缀函数的性质，f(n) = j，那么s[0, j-1] = s[n-j+1,n] --「公式1」
- 前缀函数在字符串匹配中的作用？
  - 假设主串s="abcasabc"，模式串t="cas"
  - 如果我们将模式串和主串，用一个不会出现的字符"#"号连接，得到字符串p="cas#abcasabc"
  - 如果对p求解前缀函数，那么f(8) = 3，此时3 === t.length，说明已匹配上模式串。模式串在主串的出现的start = 8 -「拼接的前缀长度」-「f(8)」 + 1 = 2，那么end =  8 -「拼接的前缀长度」= 4，所以模式串t在主串s中的位置是s[2， 4]
- 前缀函数的求解过程：
  - 假设f(n) = j，求解f(n+1)，那么如果s[j] = s[n+1]，由「公式1」可得，s[0, j] = s[n-j+1, n+1]，可以推断f(n+1) = j + 1
  - 假设f(n) = j，求解f(n+1)，那么如果s[j] != s[n+1]，情况比较麻烦一些
    - 暴力求解：依次核对s[0] = s[n+1]？、s[1] = s[n]?、s[2] = s[n-1]?...，这么求解出来的话，时间复杂度将会变成o(s.length * s.length)
    - 因此需要利用前缀函数的特性来求解，在假定条件下，有s[0, j-1] = s[n-j+1,n]，那么「公式1」两边字符串前缀均加x（相当于子串也相等），s[x, j-1] = s[n-j+1+x, n]是成立的（其中x < j-1），根据前缀函数的特性，其实我们需要关注的是字符串的前缀和后缀，但s[x, j-1]并不属于s(n)前缀/s(n)后缀中的一种，与s[n-j+1+x, n]对应的前缀是s[0, j-1-x]。这里我们发现
      1. s[x, j-1]属于s(j-1)的后缀，s[0, j-1-x]属于s(j-1)的前缀
      2. s[n-j+1+x, n]属于s(n)的后缀，s[0, j-1-x]也属于s(n)的前缀
      3. 如果s[0, j-1-x] = s[x, j-1]成立，且有s[x, j-1] = s[n-j+1+x, n]，可推得s[0, j-1-x]=s[n-j+1+x, n]成立
      4. 如果保证s[0, j-1-x]是最长的，且条件3成立，等价于s[0, j-1-x].length = f(j-1)，其实前提就是下次找的j指针的位置=f(j-1)
      5. j找到下一次循环位置之后，其实就是j = j - x = f(j-1)，继续回到前缀函数求解过程的开始，判定s[j] = s[n+1]是否成立
      6. 终止条件：j = 0，如果s[0] != s[n+1]，那么f(n+1) = 0；如果s[0] = s[n+1]，那么f(n+1) = f(0) + 1 = 1
- 前缀函数的复杂度论证：
  - 最好情况，随着循环进行，s[j]=s[n+1]一直成立，将会循环s.length次，所以复杂度为o(s.length)
  - 那么我们只需要论证j=f(j-1)，这个状态转移的复杂度，f(n) < s.length，也就是说f(n)=f(n-1)+1这个+1的次数不会超过s.length，j=f(j-1)的递减次数也不会超过增加的次数，到0就会触发终止条件，所以整体上状态转移次数是小于s.length的。算上外侧循环最差复杂度不超过2*s.length，所以复杂度为o(s.length)，为线性复杂度
- 字符串匹配算法：
  - 假设主串s="abcasabc"，模式串t="cas"。前面提到一种方案，拼接为"cas#abcasabc"，然后利用前缀函数，即可求得；
    - 时间复杂度为o(s.length + t.length)
    - 空间复杂度为o(s.length + t.length)，空间复杂度有些冗余，生成了新的字符串"cas#abcasabc"，且需要一个数组来存储f(1)、f(2)...f(s.length + t.length)
  - 浪费的空间，可以使用指针来替代
    ```javascript
    var strStr = function (s, t) {
      const next = [0] // t的前缀函数值
      for(let i = 1, j = next[0]; i < t.length; i++) {
        while(t[i] !== t[j] && j > 0) {
          j = next[j - 1]
        }
        if(t[i] === t[j]) {
          j++
        }
        next[i] = j
      }
      // 依然可以认为这是一个前缀函数求解过程，无非指针j在另一个字符串上，正常前缀函数求解的话这个指针在同一个字符串上
      for(let i = 0, j = 0; i < s.length;) {  
        while(s[i] !== t[j] && j > 0) {
          j = next[j - 1]
        }
        if(s[i] === t[j]) {
          i++
          j++
        }
        if(j === 0) {
          i++
        }

        if(j === t.length) {
          return i - t.length
        }
      }

      return -1
    }
    ```
